using Neuromatic.Core;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using TensorFlow;

namespace Neuromatic.TensorFlow
{
    /// <summary>
    /// A TensorFlow specific backend function. This function is used to execute parts of the 
    /// computation graph generated by the tensorflow backend.
    /// </summary>
    public class TensorFlowBackendFunction : BackendFunction
    {
        private TFSession _session;
        
        /// <summary>
        /// Initializes a new instance of <see cref="TensorFlowBackendFunction"/>
        /// </summary>
        /// <param name="session"></param>
        /// <param name="inputs"></param>
        /// <param name="outputs"></param>
        public TensorFlowBackendFunction(
            TFSession session, 
            IDictionary<ExecutableModelNode, object> inputs, 
            IEnumerable<ExecutableModelNode> outputs)
            : base(inputs, outputs)
        {
            _session = session;
        }

        /// <summary>
        /// Executes the function on the tensorflow session
        /// </summary>
        /// <returns>Returns the fetched outputs</returns>
        public override IEnumerable<object> Execute(IDictionary<ExecutableModelNode, object> inputs)
        {
            var runner = _session.GetRunner();

            var (inputSymbols, inputValues) = MapInputValues(MergeInputValues(inputs));
            var outputSymbols = Outputs.Select(x => ((TensorFlowGraphNode)x).Value).ToArray();

            var outputValues = _session.Run(
                inputSymbols.ToArray(),
                inputValues.ToArray(),
                outputSymbols.ToArray());

            return outputValues.Select(x => MapOutputValue(x)).ToList();
        }

        /// <summary>
        /// Validates and maps a single input value.
        /// Currently we support only float and float[] as value types.
        /// </summary>
        /// <param name="value">Input value to map to a tensor</param>
        /// <returns>A tensor containing the mapped value</returns>
        TFTensor MapInputValue(object value)
        {
            switch (value)
            {
                case float[] floats:
                    return new TFTensor(floats);
                case float floatValue:
                    return new TFTensor(floatValue);
                default:
                    throw new ArgumentException($"Specified value type {value.GetType()} is not supported");
            }
        }
        
        /// <summary>
        /// Maps the output value of the given tensor to a raw value that is usable in the .NET runtime.
        /// </summary>
        /// <param name="tensor">Tensor to extract the value from</param>
        /// <returns>Returns the mapped .NET runtime compatible value</returns>
        object MapOutputValue(TFTensor tensor)
        {
            return tensor.GetValue();
        }

        /// <summary>
        /// Maps input values from the input dictionary to separate lists of symbols and values.
        /// </summary>
        /// <param name="inputValues">Input values to map</param>
        /// <returns>Returns a list of symbols and a list of values for the symbols. Entries match on index.</returns>
        (IEnumerable<TFOutput>, IEnumerable<TFTensor>) MapInputValues(IDictionary<ExecutableModelNode, object> inputValues)
        {
            var symbols = new List<TFOutput>();
            var values = new List<TFTensor>();

            foreach (var keyValuePair in inputValues)
            {
                symbols.Add(((TensorFlowGraphNode)keyValuePair.Key).Value);
                values.Add(MapInputValue(keyValuePair.Value));
            }

            return (symbols, values);
        }
    }
}
