using Neuromatic.Core;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using TensorFlow;

namespace Neuromatic.TensorFlow
{
    /// <summary>
    /// A TensorFlow specific backend function. This function is used to execute parts of the 
    /// computation graph generated by the tensorflow backend.
    /// </summary>
    public class TensorFlowBackendFunction : BackendFunction
    {
        private TFSession _session;

        /// <summary>
        /// Initializes a new instance of <see cref="TensorFlowBackendFunction"/>
        /// </summary>
        /// <param name="session"></param>
        /// <param name="inputs"></param>
        /// <param name="outputs"></param>
        public TensorFlowBackendFunction(
            TFSession session,
            IEnumerable<ExecutableModelNode> inputs,
            IEnumerable<ExecutableModelNode> outputs,
            IEnumerable<ExecutableModelNode> updates)
            : base(inputs, outputs, updates)
        {
            _session = session;
        }

        /// <summary>
        /// Executes the function on the tensorflow session
        /// </summary>
        /// <returns>Returns the fetched outputs</returns>
        public override IEnumerable<object> Execute(IEnumerable<object> inputValues)
        {
            var runner = _session.GetRunner();

            var inputSymbols = MapInputSymbols();
            var inputTensors = MapInputValues(inputValues);
            var outputSymbols = Outputs.Select(x => ((TensorFlowGraphNode)x).Value).ToArray();

            var outputValues = _session.Run(
                inputSymbols.ToArray(),
                inputTensors.ToArray(),
                outputSymbols.ToArray());

            return outputValues.Select(x => MapOutputValue(x)).ToList();
        }

        /// <summary>
        /// Validates and maps a single input value.
        /// Currently we support only float and float[] as value types.
        /// </summary>
        /// <param name="value">Input value to map to a tensor</param>
        /// <returns>A tensor containing the mapped value</returns>
        TFTensor MapInputValue(object value)
        {
            switch (value)
            {
                case Array arrayValue:
                    return new TFTensor(arrayValue);
                case float floatValue:
                    return new TFTensor(floatValue);
                default:
                    throw new ArgumentException($"Specified value type {value.GetType()} is not supported");
            }
        }

        /// <summary>
        /// Maps the output value of the given tensor to a raw value that is usable in the .NET runtime.
        /// </summary>
        /// <param name="tensor">Tensor to extract the value from</param>
        /// <returns>Returns the mapped .NET runtime compatible value</returns>
        object MapOutputValue(TFTensor tensor)
        {
            return tensor.GetValue();
        }

        /// <summary>
        /// Maps input values from the input dictionary to separate lists of symbols and values.
        /// </summary>
        /// <param name="inputValues">Input values to map</param>
        /// <returns>Returns a list of symbols and a list of values for the symbols. Entries match on index.</returns>
        IEnumerable<TFOutput> MapInputSymbols()
        {
            return Inputs.Select(x => ((TensorFlowGraphNode)x).Value);
        }

        IEnumerable<TFTensor> MapInputValues(IEnumerable<object> inputValues)
        {
            return inputValues.Select(x => MapInputValue(x));
        }
    }
}
